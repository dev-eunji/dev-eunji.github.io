---
title: "[TIL] 2021.02.01 - 2021.02.07"
categories: [TIL]
tags: [TIL]
last_modified_at: 2021-02-01
permalink: /til/:year/:month/:day/:title/
comments: true
---

## todo

- [ ] 클린아키텍처 2독
- [x] 데이터바인딩
- [ ] 데이터바인딩 with recyclerview
- [ ] mvvm과 데이터바인딩, recyclerview 를 활용한 샘플 todo 앱
- [x] Service lifecycle
- [x] View lifecycle
- [ ] observer 패턴
- [ ] strategy 패턴
- [x] activity flag

## What I learned

1. intArrayOf() -> IntArray -> int[]

2. `by viewModels()`

- `ViewModelProvider` 사용 없이 `ViewModel`을 지연 생성할 수 있다.

  ```kotlin
   // asis
   private lateinit var viewModel: MainViewModel
   viewModel = ViewModelProvider(this).get(MainViewModel::class.java)

   // tobe
   private val viewModel: MainViewModel by viewModels()
  ```

  - `by viewModels()`는 종속성 추가 후 사용할 수 있다.

  - [참고1](https://developer.android.com/jetpack/androidx/releases/activity), [참고2]()

  ```
  dependencies {
      implementation "androidx.fragment:fragment-ktx:1.2.5"
  }
  ```

3. `@RequireApi()` vs. `@TargetApi()`

- 둘 다 런타임에 예외처리를 수행하지는 않으며, 단지 IDE에 알리는 역할을 한다.
- 차이점
  - `@RequireApi()`: 해당 API 버전 이상에서 호출되어야해!
    - 사용하는 쪽 소스에서 버전 체크를 하지 않으면 알려준다.
  - `@TargetApi()`: 해당 API 버전에서만 호출된다~

4. LiveData: UI 스레드에서는 setValue(), 백그라운드에서는 postValue() 로 값 세팅

5. Activity Flag

- [FLAG_ACTIVITY_SINGLE_TOP](https://developer.android.com/reference/android/content/Intent#FLAG_ACTIVITY_SINGLE_TOP)
  : history stack에서 최상단에 있다면(동일한 액티비티가 연속으로 호출), 새로 런치되지 않는다.

- [FLAG_ACTIVITY_CLEAR_TOP](https://developer.android.com/reference/android/content/Intent#FLAG_ACTIVITY_CLEAR_TOP)
  : 기존 스택에 있는 동일한 액티비티를 호출할 경우, 기존의 액티비티(`onNewIntent()` 호출됨) 와 그 이전에 history stack에 쌓여있는 액티비티들만 스택에 남기고 나머지는 종료됨. rootActivity만 남기고 제거
